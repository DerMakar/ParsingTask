// консольное приложение, которое одним из параметров командной строки принимает название входного файла, вторым название выходного файла
/*
* Ќаписать парсер, который принимает на вход файл, содержащий один корневой узел
* построить в пам€ти древовидное представление данных.
*  аждому узлу назначить целочисленный id.
* «атем слить данные в текстовый файл такой структуры:
	** (id узла, id вышесто€щего узла, им€ узла, значение в узле).
* ƒл€ узлов-списков вместо значени€ вывести идентификаторы его непосредственных потомков.
* ѕор€док вывода узлов в выходном файле должен быть такой же, как и во входном файле.
* —начала корневой узел, затем его первый потомок, затем первый потомок первого потомка и т.д.
*  аждый узел выводить в отдельной строке. 
* ¬ начале строки должен быть отступ в соответствии с уровнем узла в иерархии.
*  орневой узел выводитс€ без отступа, его потомки вывод€тс€ с отступом в два пробела, потомки потомков с отступом в четыре пробела и т.д.
* ¬ случае наличи€ ошибок формата данных, выдавать сообщение вида "Ќеверный формат данных" без детализации ошибки и завершать работу.
*/


/*
текстовый формат дл€ хранени€ произвольных данных
иерархическа€ структура.
* им€_узла - строка из букв, цифр, и символа '_', начинающа€с€ не с цифры
* значение_узла - произвольна€ строка в двойных кавычках, не содержаща€ символов перевода строки и двойных кавычек
* узел ::= им€_узла '=' (значение_узла | список )
* список ::= '{' узел [узел ... ] '}'
*/

#include "document.h"

using namespace std::literals;

void PrintUsage(std::ostream& stream = std::cerr) {
	stream << "Usage: document [infile|outfile]\n"sv;
}

/*
int main(int argc, char* argv[]) {
	if (argc != 2) {
		PrintUsage();
		return 1;
	}
	const std::string_view infile(argv[0]);
	const std::string_view outfile(argv[1]);
	rstyle::Document document(infile);
	document.Print(outfile);
	return 0;
}
*/

int main() {
	rstyle::Document document("input.txt");
	document.Print("output.txt");
	return 0;
}